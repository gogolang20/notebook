
create database if not exists test character set 'utf8'; //创建数据库

CREATE TABLE  if not exists  `test` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  
  `t_name` varchar(20) DEFAULT "",

  `t_number` bigint unsigned DEFAULT 0,

  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

  `123` tinyint(1) DEFAULT 0,
  `123` int unsigned DEFAULT 0,

#----------------------------------------------------------#----------------------------------------------------------#
#----------------------------------------------------------#----------------------------------------------------------#
1 开启慢查询                 #https://blog.csdn.net/keketrtr/article/details/95636815
2 account_address 建立索引
3 设置MySQL事务级别          #https://dev.mysql.com/doc/refman/8.0/en/set-transaction.html
4 explain 查看语句执行细节

show variables like 'slow_query%';
show variables like 'long_query%';
$ slow_query_log 慢查询开启状态,ON开启,OFF关闭
$ slow_query_log_file 慢查询日志存放的位置(这个目录需要MySQL的运行帐号的可写权限,一般设置为MySQL的数据存放目录)
$ long_query_time 查询超过多少秒才记录(才算是慢查询)

一、临时开启(数据库服务重启后失效)
set global slow_query_log_file='/var/lib/mysql/tmp_slow.log';
set global long_query_time=1;
set global slow_query_log='ON';
long_query_time设置后需要打开一个新的查询窗口(会话)才能看到新设置的值。老的查询窗口还是显示之前的值,其实已经改了。
二、永久开启(数据库服务重启后不失效)
修改配置文件my.cnf,在[mysqld]下的下方加入
[mysqld]
slow_query_log = ON
slow_query_log_file = /var/lib/mysql/tmp_slow.log     //linux
long_query_time = 1
然后重启mysql服务。
原文链接:https://blog.csdn.net/keketrtr/article/details/95636815

#----------------------------------------------------------#----------------------------------------------------------#
#----------------------------------------------------------#----------------------------------------------------------#
#----------------------------------------------------------#----------------------------------------------------------#

备份数据库方式
-- 创建一个和原表一样的备份表(包含索引)
create table wormholesscan_Account_bak like wormholesscan_Account;
create table wormholesscan_AccountNFT_bak like wormholesscan_AccountNFT;

-- 拷贝数据到备份表
INSERT into wormholesscan_Account_bak select * from wormholesscan_Account;
INSERT into wormholesscan_AccountNFT_bak select * from wormholesscan_AccountNFT;

-- 确认数据拷贝完成
select * from wormholesscan_Account_bak;
select * from wormholesscan_AccountNFT_bak;



# MySQL基础

### Show

```mysql
>show engines;
>show databases;
>show tables;

>show create database atguigudb; #查看创建database 的命令
>show create table employees; #查看创建table 的命令

>show variables like 'character_%';

>source /root/mysql_sql/atguigudb.sql 
```



## DQL 查询语句！！！

```mysql
Syntax:
SELECT
    [ALL | DISTINCT | DISTINCTROW ]
    [HIGH_PRIORITY]
    [STRAIGHT_JOIN]
    [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]
    [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]
    select_expr [, select_expr] ...
    [into_option]
    [FROM table_references
      [PARTITION partition_list]]
    [WHERE where_condition]
    [GROUP BY {col_name | expr | position}
      [ASC | DESC], ... [WITH ROLLUP]]
    [HAVING where_condition]
    [ORDER BY {col_name | expr | position} #分页
      [ASC | DESC], ...]
    [LIMIT {[offset,] row_count | row_count OFFSET offset}] #排序
    [PROCEDURE procedure_name(argument_list)]
    [into_option]
    [FOR UPDATE | LOCK IN SHARE MODE]

into_option: {
    INTO OUTFILE 'file_name'
        [CHARACTER SET charset_name]
        export_options
  | INTO DUMPFILE 'file_name'
  | INTO var_name [, var_name] ...
}

```

```mysql
>select * from employees;
>select employee_id,email from employees;

>select employee_id emp_id,email from employees; #别名 方式一
>select employee_id emp_id,email AS em from employees; #别名 方式二,AS
>select employee_id emp_id,email AS "邮 箱" from employees; #别名 方式三,用双引号

#去除重复行
>select distinct department_id from employees; #distinct 关键字
>select distinct department_id,salary from employees;

```

```mysql
#空值参与运算
#空值:null,不等同于0 或者 ''
>select employee_id,salary "月工资",salary * (1 + commission_pct) * 12 "年工资",commission_pct from employees; #空值参与运算,结果一定也为空
>select employee_id,salary "月工资",salary * (1 + ifnull(commission_pct,0)) * 12 "年工资",commission_pct from employees; #ifnull 处理

#反引号
>select * from order; #报错
>select * from `order`; #正确

#查询常数
>select 'MySQL',employee_id,email from employees;

#显示表结构
>describe employees;
>desc employees;

#Where 过滤条件
>select * from employees where department_id = 90;
>select * from employees where last_name = 'King';
```

### 运算符

算术运算符

```mysql
>SELECT 100, 100 + 0, 100 - 0, 100 + 50, 100 + 50 -30, 100 + 35.5, 100 - 35.5 FROM dual;
#dual 伪表
>SELECT 100, 100 * 1, 100 * 1.0, 100 / 1.0, 100 / 2,100 + 2 * 5 / 2,100 /3, 100 DIV 0 FROM dual;

>SELECT employee_id,last_name,salary FROM employees where employee_id % 2 = 0; 

>SELECT employee_id,salary,salary * 12 annual_sal FROM employees;

```

比较运算符

```mysql
比较运算符用来对表达式左边的操作数和右边的操作数进行比较,比较的结果为真则返回1,比较的结果为假则返回0,其他情况则返回NULL
1 等号运算符(=)判断等号两边的值、字符串或表达式是否相等,如果相等则返回1,不相等则返回0。
>SELECT employee_id,salary FROM employees WHERE salary = 10000;

2 安全等于运算符(<=>)与等于运算符(=)的作用是相似的,唯一的区别是‘<=>’可以用来对NULL进行判断。
>SELECT employee_id,commission_pct FROM employees WHERE commission_pct = 0.40;
>SELECT employee_id,commission_pct FROM employees WHERE commission_pct <=> 0.40;

3 不等于运算符(<>和!=)用于判断两边的数字、字符串或者表达式的值是否不相等,如果不相等则返回1,相等则返回0。
>SELECT 1 <> 1, 1 != 2, 'a' != 'b', (3+4) <> (2+6), 'a' != NULL, NULL <> NULL; 

4 空运算符(IS NULL或者ISNULL)判断一个值是否为NULL,如果为NULL则返回1,否则返回0。
>SELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NULL; #常用
>SELECT employee_id,commission_pct FROM employees WHERE commission_pct <=> NULL;
>SELECT employee_id,commission_pct FROM employees WHERE ISNULL(commission_pct);
>SELECT employee_id,commission_pct FROM employees WHERE commission_pct = NULL; #查不出来

5 非空运算符(IS NOT NULL)判断一个值是否不为NULL,如果不为NULL则返回1,否则返回0。
>SELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NOT NULL; #常用
>SELECT employee_id,commission_pct FROM employees WHERE NOT commission_pct <=> NULL;
>SELECT employee_id,commission_pct FROM employees WHERE NOT ISNULL(commission_pct);

6 最小值运算符
>SELECT LEAST (1,0,2), LEAST('b','a','c'), LEAST(1,NULL,2);
select least(first_name,last_name),least(length(first_name),length(last_name)) from employees;
7 最大值运算符
>SELECT GREATEST(1,0,2), GREATEST('b','a','c'), GREATEST(1,NULL,2);

8 BETWEEN AND运算符
>SELECT last_name, salary FROM employees WHERE salary BETWEEN 2500 AND 3500; #AND 
>SELECT last_name, salary FROM employees WHERE salary NOT BETWEEN 2500 AND 3500; #NOT
>SELECT last_name, salary FROM employees WHERE salary < 2500 OR salary > 3500; #OR

9 IN运算符用于判断给定的值是否是IN列表中的一个值,如果是则返回1,否则返回0。如果给定的值为NULL,或者IN列表中存在NULL,则结果为NULL。
>SELECT last_name,salary,department_id FROM employees WHERE department_id IN (10,20,30); 

10 NOT IN运算符用于判断给定的值是否不是IN列表中的一个值,如果不是IN列表中的一个值,则返回1,否则返回0。
>SELECT last_name,salary,department_id FROM employees WHERE salary NOT IN (6000,7000,8000); 

11 LIKE运算符主要用来匹配字符串,通常用于模糊匹配,如果满足条件则返回1,否则返回0。如果给定的值或者匹配条件为NULL,则返回结果为NULL。
“%”:匹配0个或多个字符。
“_”:只能匹配一个字符。
>SELECT last_name FROM employees WHERE last_name LIKE '__o%';

12 REGEXP运算符用来匹配字符串,语法格式为:expr REGEXP 匹配条件。如果expr满足匹配条件,返回1；如果不满足,则返回0。若expr或匹配条件任意一个为NULL,则结果为NULL。
>SELECT 'shkstart' REGEXP '^s', 'shkstart' REGEXP 't$', 'shkstart' REGEXP 'hk';

```

逻辑运算符

```
OR ||
AND &&
NOT !
XOR 异或
```

### 排序与分页

```mysql
order by #列的别名只能在order by中使用
ASC(ascend): 升序
DESC(descend): 降序
>select employee_id,last_name,salary from employees order by salary desc; #降序
>select employee_id,last_name,salary from employees order by salary; #默认升序

多列排序
>select department_id,last_name,salary from employees order by salary desc,department_id asc;

分页
>select employee_id,last_name,salary from employees limit 0,20; #偏移量 + 条目数
>select employee_id,last_name,salary from employees limit 20,20; #第二页

>select employee_id,last_name,salary from employees 
where salary > 6000 
order by salary desc 
limit 0,10;

```

### 多表查询

```mysql
>select employee_id,department_name 
from employees,departments 
where employees.`department_id` = departments.department_id; #用点 '.'
#表名.列名

>select employee_id,department_name,employees.department_id
from employees,departments 
where employees.`department_id` = departments.department_id; 

#练习:查询员工employee_id,last_name,department_name,city
#声明的别名必须要使用
#不同table的列名相同,必须要添加table名称前缀
>select e.employee_id,last_name,department_name,city
from employees e,departments d,locations l
where e.`department_id` = d.department_id AND d.location_id = l.location_id;

#非等值连接
>select last_name,salary,grade_level
from employees e,job_grades j
where e.salary between j.lowest_sal AND j.highest_sal;

#自连接
#练习:查询员工id,员工姓名及其管理者的id和姓名
>select emp.employee_id,emp.last_name,mgr.employee_id,mgr.last_name
from employees emp,employees mgr
where emp.`manager_id` = mgr.`employee_id`;

```

```mysql
内连接:合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行

外连接:两个表在连接过程中除了返回满足连接条件的行以外还返回左(或右)表中不满足条件的行,这种连接称为左(或右) 外连接。没有匹配的行时, 结果表中相应的列为空(NULL)。
外连接的分类:左外连接、右外连接、满外连接
# Join ... on SQL99语法实现内连接
>select employee_id,department_name 
from employees e join departments d 
on e.department_id = d.department_id;
>select employee_id,department_name,city 
from employees e join departments d 
on e.department_id = d.department_id
join locations l 
on d.location_id = l.location_id;

#SQL99语法实现外连接
#left outer join 左外连接
>select last_name,department_name 
from employees e left outer join departments d 
on e.department_id = d.department_id;
#右外连接
>select last_name,department_name 
from employees e right outer join departments d 
on e.department_id = d.department_id;
#满外连接 union; union all
#七种jion的实现
>select employee_id,department_name 
from employees e join departments d 
on e.department_id = d.department_id;

>select employee_id,department_name 
from employees e left join departments d 
on e.department_id = d.department_id;

>select employee_id,department_name 
from employees e right join departments d 
on e.department_id = d.department_id;

>select employee_id,department_name 
from employees e left join departments d 
on e.department_id = d.department_id
where d.department_id is null;

>select employee_id,department_name 
from employees e right join departments d 
on e.department_id = d.department_id
where e.department_id is null;

#MySQL实现满外连接
>select employee_id,department_name 
from employees e left join departments d 
on e.department_id = d.department_id
union all 
select employee_id,department_name 
from employees e right join departments d 
on e.department_id = d.department_id
where e.department_id is null;

#剔除并集部分
>select employee_id,department_name 
from employees e left join departments d 
on e.department_id = d.department_id
where d.department_id is null
union all
select employee_id,department_name 
from employees e right join departments d 
on e.department_id = d.department_id
where e.department_id is null;

```

### 单行函数

```
参考资料
```

日期和时间

```mysql
mysql> select curdate(),curtime(),now() from dual;
+------------+-----------+---------------------+
| curdate()  | curtime() | now()               |
+------------+-----------+---------------------+
| 2021-12-17 | 16:12:24  | 2021-12-17 16:12:24 |
+------------+-----------+---------------------+
1 row in set (0.05 sec)

计算日期和时间的函数 ！！！
mysql> select now(),date_add(now(),interval 1 year),date_sub(now(),interval 1 year) from dual;
+---------------------+---------------------------------+---------------------------------+
| now()               | date_add(now(),interval 1 year) | date_sub(now(),interval 1 year) |
+---------------------+---------------------------------+---------------------------------+
| 2021-12-17 16:31:16 | 2022-12-17 16:31:16             | 2020-12-17 16:31:16             |
+---------------------+---------------------------------+---------------------------------+
1 row in set (0.00 sec)

```

流程控制

```mysql
mysql> select last_name,salary,if(salary > 6000,"高工资","低工资") "details" from employees;
 ...
```

加密与解密函数

```mysql
mysql> select md5('mysql'),sha('mysql') from dual;
+----------------------------------+------------------------------------------+
| md5('mysql')                     | sha('mysql')                             |
+----------------------------------+------------------------------------------+
| 81c3b080dad537de7e10e0987a4bf52e | f460c882a18c1304d88854e902e11b85d71e7e1b |
+----------------------------------+------------------------------------------+
1 row in set (0.00 sec)
#MD5 sha 不可逆的加密函数

mysql> select version(),connection_id(),database(),schema(),user() from dual;
+-----------+-----------------+------------+-----------+----------------+
| version() | connection_id() | database() | schema()  | user()         |
+-----------+-----------------+------------+-----------+----------------+
| 5.7.36    |               2 | atguigudb  | atguigudb | root@localhost |
+-----------+-----------------+------------+-----------+----------------+
1 row in set (0.01 sec)

mysql> select inet_aton('192.168.152.156'),inet_ntoa(3232274588) from dual;
+------------------------------+-----------------------+
| inet_aton('192.168.152.156') | inet_ntoa(3232274588) |
+------------------------------+-----------------------+
|                   3232274588 | 192.168.152.156       |
+------------------------------+-----------------------+
1 row in set (0.00 sec)

```

### 聚合函数

聚合函数

```mysql
#常见的几个聚合函数:
#avg sum 只适用于 数值类型的字段(或变量)
#max min 适用于 数值 字符串 时间 类型的字段(或变量)
#count
#avg = sum / count
mysql> select avg(salary),sum(salary),max(salary),min(salary),count(salary) from employees;
+-------------+-------------+-------------+-------------+---------------+
| avg(salary) | sum(salary) | max(salary) | min(salary) | count(salary) |
+-------------+-------------+-------------+-------------+---------------+
| 6461.682243 |   691400.00 |    24000.00 |     2100.00 |           107 |
+-------------+-------------+-------------+-------------+---------------+
1 row in set (0.00 sec)
```

Group by 的使用

```mysql
mysql> select department_id,avg(salary),sum(salary) from employees group by department_id;
+---------------+--------------+-------------+
| department_id | avg(salary)  | sum(salary) |
+---------------+--------------+-------------+
|          NULL |  7000.000000 |     7000.00 |
|            10 |  4400.000000 |     4400.00 |
|            20 |  9500.000000 |    19000.00 |
|            30 |  4150.000000 |    24900.00 |
|            40 |  6500.000000 |     6500.00 |
|            50 |  3475.555556 |   156400.00 |
|            60 |  5760.000000 |    28800.00 |
|            70 | 10000.000000 |    10000.00 |
|            80 |  8955.882353 |   304500.00 |
|            90 | 19333.333333 |    58000.00 |
|           100 |  8600.000000 |    51600.00 |
|           110 | 10150.000000 |    20300.00 |
+---------------+--------------+-------------+
12 rows in set (0.00 sec)

mysql> select department_id,job_id,avg(salary),sum(salary) from employees group by department_id,job_id;
+---------------+------------+--------------+-------------+
| department_id | job_id     | avg(salary)  | sum(salary) |
+---------------+------------+--------------+-------------+

mysql> select department_id,avg(salary),sum(salary) from employees group by department_id with rollup;
+---------------+--------------+-------------+
| department_id | avg(salary)  | sum(salary) |
+---------------+--------------+-------------+

```

Having 的使用

```mysql
mysql> select department_id,max(salary) from employees group by department_id having max(salary) > 10000;
+---------------+-------------+
| department_id | max(salary) |
+---------------+-------------+
|            20 |    13000.00 |
|            30 |    11000.00 |
|            80 |    14000.00 |
|            90 |    24000.00 |
|           100 |    12000.00 |
|           110 |    12000.00 |
+---------------+-------------+
6 rows in set (0.00 sec)

#方式一 效率高于方式二
mysql> select department_id,max(salary) 
from employees 
where department_id in (10,20,30,40)
group by department_id 
having max(salary) > 10000;
#方式二
mysql> select department_id,max(salary) 
from employees 
group by department_id 
having max(salary) > 10000 and department_id in (10,20,30,40);

#当过滤条件中有聚合函数时,则此过滤条件必须声明在having 中
```

SQL 底层执行原理

```mysql
#一 select 语句的完整结构
mysql> help select

#二 SQl语句的执行过程
select ... #第二部分

from ... (left / right) join ... on #第一部分
(left / right) join ... on 
where ... 不包含聚合函数的过滤条件 
group by ...
having ... 包含聚合函数的过滤条件

order by ... (asc / desc) #第三部分
limit ...

#from -> on -> (left / right join) -> where -> group by -> having -> select -> distinct ->
#order by -> limit 

```

### 子查询 ！！！

```mysql
mysql> select last_name,salary 
    -> from employees 
    -> where salary > (
    -> select salary 
    -> from employees 
    -> where last_name = "Abel"
    -> );
+-----------+----------+
| last_name | salary   |
+-----------+----------+
| King      | 24000.00 |
| Kochhar   | 17000.00 |
| De Haan   | 17000.00 |
| Greenberg | 12000.00 |
| Russell   | 14000.00 |
| Partners  | 13500.00 |
| Errazuriz | 12000.00 |
| Ozer      | 11500.00 |
| Hartstein | 13000.00 |
| Higgins   | 12000.00 |
+-----------+----------+
10 rows in set (0.00 sec)

```

```
#子查询的分类
#单行子查询 vs 多行子查询
#相关子查询 vs 不相关子查询
```

单行子查询

```mysql
mysql> select employee_id,last_name,salary from employees where salary >
    -> (select salary from employees where employee_id = 149);
+-------------+-----------+----------+
| employee_id | last_name | salary   |
+-------------+-----------+----------+

#having 中的子查询
mysql> select department_id,min(salary) from employees group by department_id 
    -> having min(salary) > (select min(salary) from employees where department_id = 50);
+---------------+-------------+
| department_id | min(salary) |
+---------------+-------------+

```

多行子查询

```mysql
多行比较操作符
1 in
2 any
3 all
4 some
```

```mysql
#查询平均工资最低的部门id
#方式一
select department_id 
from employees
group by department_id 
having avg(salary) = (
	select min(avg_sal) from (
		select avg(salary) avg_sal from employees group by department_id
		) t_dept_avvg_sal
);
#方式二
select department_id 
from employees
group by department_id 
having avg(salary) <= all(
	select avg(salary) avg_sal from employees group by department_id
);

```

相关子查询

```mysql
1 从主查询中获取候选列
2 子查询使用主查询的数据
3 如果满足子查询的条件则返回该行,循环到条件1
```

```mysql
#查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id
select last_name,salary,department_id
from employees e1
where salary > ( 
    select avg(salary) 
    from employees e2
    where department_id = e1.`department_id`
);
方式二
select e.last_name,e.salary,e.department_id
from employees e,(
	select department_id,avg(salary) avg_sal from employees group by department_id) t_dept_avg_sal
where e.department_id = t_dept_avg_sal.department_id
and e.salary > t_dept_avg_sal.avg_sal;

在select结构中 除了group by 和 limit外,其他位置都可以写子查询！！！
```

```mysql
1 exists
mysql> select employee_id,last_name,job_id,department_id from employees e1 where exists  (select * from employees e2 where e1.employee_id = e2.manager_id);
+-------------+
| employee_id |
+-------------+

2 not exists
mysql> select department_id,department_name from departments d where not exists (
    -> select * from employees e where d.department_id = e.department_id);
+---------------+----------------------+
| department_id | department_name      |
+---------------+----------------------+
```



```
mysql> select j.* from jobs j,(select job_id,avg(salary) avg_sal from employees group by job_id order by avg_sal desc limit 0,1) t_job_avg_sal where j.job_id = t_job_avg_sal.job_id;
+---------+-----------+------------+------------+
| job_id  | job_title | min_salary | max_salary |
+---------+-----------+------------+------------+
| AD_PRES | President |      20000 |      40000 |
+---------+-----------+------------+------------+

```



## DML 数据操作语句

```mysql
1 Insert 添加
2 Update 修改
3 Delete 删除
4 Select 查询 #上面单独记录

mysql> use atguigudb; #基于atguigudb 数据库操作
mysql> create table if not exists emp1 (
    -> id int,
    -> name varchar(15),
    -> hire_date date,
    -> salary double(10,2)
    -> );
mysql> desc emp1;
+-----------+--------------+------+-----+---------+-------+
| Field     | Type         | Null | Key | Default | Extra |
+-----------+--------------+------+-----+---------+-------+
| id        | int(11)      | YES  |     | NULL    |       |
| name      | varchar(15)  | YES  |     | NULL    |       |
| hire_date | date         | YES  |     | NULL    |       |
| salary    | double(10,2) | YES  |     | NULL    |       |
+-----------+--------------+------+-----+---------+-------+
mysql> select * from emp1;
```

### Insert 添加数据

```mysql
方式一:一条一条的添加
mysql> insert into emp1 values(1,'Tom','2000-12-21',3400); #要按照声明的字段先后顺序添加

mysql> insert into emp1(id,hire_date,salary,name) values(2,'1999-09-09',4000,'Jerry');
mysql> insert into emp1(id,salary,name) values(3,4500,'shk');
mysql> select * from emp1;

mysql> insert into emp1(id,salary,name) values(4,5000,'Jim'),(5,5500,'俊杰');

方式二:将查询结果插入到表中
mysql> select * from emp1;

mysql> insert into emp1(id,name,salary,hire_date)
    -> select employee_id,last_name,salary,hire_date
    -> from employees 
    -> where department_id in (70,60);
#emp1 表中要添加数据的字段的长度不能低于 employees 表中查询的字段的长度
#否则会有添加不成功的风险

mysql> select * from emp1;

```

### Update 更新数据

```mysql
# update ... set ... where ...
mysql> update emp1 set hire_date=curdate() where id=5;
mysql> select * from emp1;

mysql> update emp1 set hire_date=curdate(),salary=6000 where id=4;

```

### Delete 删除数据

```mysql
# delete from emp1 [where 条件]
# delete from emp1; #会全部删除数据,避免！
mysql> delete from emp1 where id=1; #删除指定数据

Delete和Truncate相同点:都能删除数据,都不会删除表结构
不同点Truncate:重新设置自增列 计数器会归零；不会影响事务
```



## DDL 数据定义语句

```
1 create
2 alter
3 drop
4 rename
5 truncate
```

### 创建和管理数据库

```mysql
create database XXX;
mysql> create database test; #使用默认字符集
mysql> show create database test;
+----------+---------------------------------------------------------------+
| Database | Create Database                                               |
+----------+---------------------------------------------------------------+
| test     | CREATE DATABASE `test` /*!40100 DEFAULT CHARACTER SET utf8 */ |
+----------+---------------------------------------------------------------+

mysql> create database test2 character set 'gbk';
mysql> show create database test2\g

mysql> create database if not exists test character set 'gbk';
mysql> show create database test;

#查看当前使用的数据库
mysql> select database() from dual;
mysql> show tables from information_schema;
+---------------------------------------+
| Tables_in_information_schema          |
+---------------------------------------+

mysql> alter database test character set 'utf8';
mysql> drop database if exists test;
```

### 创建表

```mysql
方式一
CREATE TABLE if not exists`myemp1` (
`id` int,
`emp_name` varchar(20) DEFAULT NULL,
`hire_date` date NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

方式二 可以起别名作为新表字段
mysql> CREATE TABLE `myemp2` AS select employee_id,last_name,salary from employees; 
mysql> select * from myemp2; #新表会复制数据

mysql> CREATE TABLE `myemp3` AS select employee_id,last_name,salary from employees;

```

### 修改表

```mysql
mysql> desc myemp1;
添加一个字段
mysql> alter table myemp1 add salary double(10,2); #默认添加到最后一个字段

mysql> alter table myemp1 add phone_number varchar(20) first;
mysql> alter table myemp1 add email varchar(45) after emp_name;

修改一个字段
mysql> alter table myemp1 modify emp_name varchar(25);
mysql> alter table myemp1 modify emp_name varchar(45) default '默认值';

重命名一个字段
mysql> alter table myemp1 change salary monthly_salary double(10,2);
mysql> alter table myemp1 change email my_email varchar(50);

删除一个字段
mysql> alter table myemp1 drop column my_email;

```



```mysql
mysql> show tables;

重命名表
mysql> rename table myemp1 to myemp11; #推荐
mysql> alter table myemp2 rename to myemp12;

删除表 
#无法撤销,只能通过日志文件
#删除表结构,同时删除表中数据,释放表空间
mysql> drop table if exists myemp12;

清空表
#清空表中所有数据,但是表结构保留
mysql> select * from myemp2;
mysql> truncate table myemp2; #表结构保留
mysql> desc myemp2; 

```

### 对比truncate table 和 delete from

```mysql
相同点:都可以实现对表中所有数据的删除,同时保留表结构

不同点:
truncate table:一旦执行,表数据全部清除,同时,数据时不可以回滚的
delete from:可以删除部分或者所有数据,同时数据是可以回滚的

DDL 和 DML 的说明
DDL:操作一旦执行,就不可以回滚(操作之后,一定会执行一次commit,且不受 set autocommit = false 影响)
DML:默认情况,操作一旦执行,也不可以回滚。但是,设置 set autocommit = false,则可以回滚

演示
mysql> commit;
mysql> select * from myemp3;
mysql> set autocommit = false;
mysql> delete from myemp3;
mysql> select * from myemp3;
mysql> rollback;
mysql> select * from myemp3;

mysql> set autocommit = true; #还原
```



## DCL 数据控制语言

```
1 commit 提交 事物 #一旦执行commit 提交数据,数据将永久保存,无法回滚
2 rollback 回滚 事物
3 savepoint
4 grant 赋予权限
5 revoke 回收权限
```

### commit && rollback

```mysql
mysql> commit;
mysql> rollback;

mysql> set autocommit = false;
mysql> set autocommit = true;

```



# MySQL高级

```
优化
慢查询
执行计划
perf
```



### 事务

```
什么是事务:要么都成功,要么都失败
事务原则(ACID原则):原子性 一致性 隔离性 持久性
```

```
隔离所导致的一些问题:
脏读:一个事务读取了另一个事务未提交的数据
不可重复读:在一个事务内读取表中的某一行数据,多次读取结果不同(这个不一定是错误,只是某些场合不对)
虚读(幻读):指在一个事务内读取到了别的事务插入的数据,导致前后读取不一致
```



### 索引

索引是帮助MySQL高效获取数据的数据结构

MySQL索引使用B+树结构

### 索引的分类

在一个表中,主键索引只能有一个,唯一索引可以有多个
1 主键索引:唯一的标识,主键不可重复,只能有一个列作为主键
2 唯一索引:避免重复的列出现,唯一索引可以重复。多个列都可以标识为 唯一索引
3 常规索引: 默认的, index, key关键字来设置
4 全文索引: 在特定的数据库引擎下才有, myisam
	快速定位数据



索引不是越多越好
不要对经常变动数据加索引
小数据量的表不需要加索引
索引一般加在常用来查询的字段上！

为什么需要数据库 规范化？
信息重复
更新异常
插入异常:
    无法正常显示信息
删除异常:
    丢失有效的信息


### 三大范式

```
第一范式
原子性:保证每一列不可再分
第二范式
前提:满足第一范式
每张表只描述一件事情
第三范式
前提:满足第一范式 和第二范式
确保数据表中的每一列数据都和主键直接相关,而不能间接相关
```

考虑到规范性和性能的问题！！！
关联查询的表不得超过三张表:
1 考虑商业化的需求和目标(成本、用户体验！)数据库的性能更加重要。
2 再规范性能的问题的时候,需要适当考虑一下规范性！
3 故意给某些表增加一些冗余的字段(从多表查询中变为单表查询)
4 故意增加一些计算列(从大数据量降低为小数据量的查询:索引)



## MySQL权限管理和数据库备份

```mysql
命令行模式备份:
>mysqldump -hlocalhost -uroot -p{password}  databaseName tableName > backup_file_location
#备份一张表命令

>mysqldump -hlocalhost -uroot -p{password}  databaseName tableName1 tableName2 > backup_file_location
#备份多张表命令

>mysqldump -hlocalhost -uroot -p{password}  databaseName > backup_file_location
#备份数据库


导入数据库:
>source /root/mysql_sql/atguigudb.sql #需要先登录到MySQL
>use atguigudb
>desc jobs; #查看table属性

>mysql -u{userName} -p{password} databaseName < backup_file #不推荐

```





MySQL磁盘扇区读取数据一次为16KB
MySQL索引使用B+树原因
三到四层结构可以支撑千万级别的数据索引条目

回表: 索引返回index后, 再根据index查询表中的数据



```
字符
Unsigned:
无符号的整数
声明了该列 不能声明为负数

Zerofull
0填充的
不足的位数,使用0来填充  int(3) ,6---- 006

自增
通常理解为自增,自动在上一条记录的基础上+1 (默认)
通常用来设计唯一的主键 index, 必须是整数类型
可以自定义设计主题键自增的起始值和步长

非空 NOT NULL
假设设置为not null 如果不给赋值,就会抱错
Null 如果不填写值, 默认就是null

默认:
设置默认的值！
如果不指定该列值,则会有默认的值！
```



