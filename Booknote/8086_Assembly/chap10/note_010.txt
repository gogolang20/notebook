CALL 和 RET 指令

位移的方式  将转移的目的地址存放在内存中


RET: 当执行ret指令时 相当于执行 pop ip

RETF: 当执行retf指令时 相当于 先执行 pop ip  在 pop cs

#---------------------------------------#

CALL 指令
push ip     ;IP 指向call 后下一条指令
jmp near ptr 标号

指令执行过程
1. CPU 从CS IP 所组合出来的地址读取指令 读到指令缓存器中
2. IP = IP + 所读指令的字节数
3. 执行指令缓存器中的内容, 回到第一步

CALL 指令的转移方式 位移的方式
16位位移

位移 = 标号处的偏移地址 - call 指令后第一个字节的地址


call far ptr 标号处的偏移地址:
push cs
push ip
jmp far ptr 标号
cs =  标号所在段的段地址  ip = 标号所在段的偏移地址 (保存的是下一条指令的内存地址)

#---------------------------------------#
转移地址在寄存器中的 call 指令

指令格式
call 16位寄存器

push ip
jmp 16位寄存器      IP = 16位寄存器中的字型数据

#---------------------------------------#
转移地址在内存中的 call 指令

指令格式
call word ptr 内存单元地址

相当于执行了
push ip
jmp word ptr 内存单元地址



指令格式
call dword ptr 内存单元地址

相当于执行了
push cs
push ip
jmp dword ptr 内存单元地址

#---------------------------------------#
call 指令的应用

call + ret/retf


函数的参数保存到内存中

#---------------------------------------#
div 乘法指令

两个数相乘 要么都是8位 要么都是16位

如果是8位 一个数字默认存放在 al中 另一个数字存放在其他8位寄存器 或者 字节型内存单元中
al      *(mul)  8位寄存器
al      *(mul)  byte ptr ds:[0]   = ax


如果是16位 一个数字默认存放在 ax中 另一个数字存放在其他16位寄存器 或者 字型内存单元中

al      *(mul)  16位寄存器
al      *(mul)  word ptr ds:[0]


结果:
8位乘法 得到一个16位的数值 结果存放在 ax 中
16位乘法 得到一个32位的数值 低16位存放在 ax 中 高16位存放在 dx 中


call 指令
